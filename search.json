[{"title":"设计模式(1)-单例模式","url":"/2020/12/30/设计模式/设计模式(1)-单例模式/","content":"## 摘要\n\n* 简单介绍了什么是单例模式\n* 介绍了懒汉式和饿汉式的实现\n* 分析了单例模式出现的场景\n* 用数据库连接池的例子演示了单例模式\n\n\n<!--more-->\n\n## 概念\n\n确保一个类只能有一个实例，并提供一个全局访问点来访问这个实例。\n\n### 要点\n\n* 某一个类只能创建一个一个实例\n* 必须类内部自行创建这个实例\n* 必须向系统提供这个实例，也就是提供一个全局访问点\n\n### 优点\n\n* 保证内存中只有一个实例，减小内存开销\n* 避免对资源的多重占用\n* 设置全局访问点，优化和共享资源的访问\n\n### 缺点\n\n* 扩展困难，如果要扩展除了修改原来的代码没有第二种开发途径，违背开闭原则\n* 单例模式的功能通常都写在一个类中，如果功能设计不合理，则很容易违反单一职责原则\n* 并发测试中不好debug\n\n## 场景\n\n对于Java来说，单例模式的落地就是在JVM中只存在单一实例。\n\n* 需要频繁创建一些类，使用单例可以降低系统的内存压力，减少GC\n* 某类只要求生成一个对象的时候，比如一个班中的班长，一个人的身份证\n\n- 某些类创建实例时占用资源较多，或实例化耗时较长，且经常使用。\n- 某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如**多线程的线程池、网络连接池**等。\n- 频繁访问数据库或文件的对象。\n- 对于一些控制硬件级别的操作，或者从系统上来讲应当是单一控制逻辑的操作，如果有多个实例，则系统会完全乱套。\n- 当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 **Web 中的配置对象、数据库的连接池**等。\n\n## 实现方式\n\n懒汉式\n\n每次访问都需要同步，会影响性能，且消耗更多的资源，这就是懒汉式的缺点\n\n```java\npublic class Lazy{\n    private static volatile Lazy instance;\n    private Lazy(){}\n    //DLC\n    public static getInstance(){\n        if(instance==null){\n            synchronized(Lazy.class){\n                if(instance==null){\n                    instance = new Lazy();\n                }\n            }\n        }\n        return instance;\n    }\n}\n```\n\n饿汉式\n\n```java\npublic class Hungry{\n    private static final Hungry instance = new Hungry();\n    private Hungry() {}\n    public static Hungry getInstance() {\n        return instance;\n    }\n}\n```\n\n## 实例\n\n获取数据库连接池\n\n```java\npublic final class DbConnectConfig {\n \n    private static ComboPooledDataSource dataSource;\n \n    static {\n        dataSource = new ComboPooledDataSource();\n        dataSource.setUser(JdbcPropertiesConfig.getUSERNAME());\n        dataSource.setPassword(JdbcPropertiesConfig.getPASSWORD());\n        dataSource.setJdbcUrl(JdbcPropertiesConfig.getDATABASEURL());\n        dataSource.setDriverClass(xxxxxxx);\n        //初始化连接数\n        dataSource.setInitialPoolSize(xxx.getINITIALPOOLSIZE());\n        //最小连接数\n        dataSource.setMinPoolSize(xxx.getMINPOOLSIZE());\n        //最大连接数\n        dataSource.setMaxPoolSize(xxx.getMAXPOOLSIZE());\n        //最长等待时间\n        dataSource.setMaxStatements(xxx.getMAXSTATEMENTS());\n        //最大空闲时间，单位毫秒\n        dataSource.setMaxIdleTime(xxx.getMAXIDLETIME());\n        dataSource.setCheckoutTimeout(5000);\n        dataSource.setUnreturnedConnectionTimeout(20);\n    }\n \n \t//这里使用DLC好一点\n    public synchronized static final Connection getConnection() {\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n        } catch (SQLException e) {\n            System.out.println(\"\\r\\n数据库连接异常\");\n            e.printStackTrace();\n        }\n        return conn;\n    }\n}\n```\n\n\n\n## 参考\n\n[1].[单例模式设置mysql数据库连接池](https://blog.csdn.net/sade1231/article/details/81562156)\n\n[2].[单例模式（单例设计模式）详解](http://c.biancheng.net/view/1338.html)\n\n[3].[学习笔记 : Java设计模式之Singleton Pattern](https://ishacker.net/2019/09/06/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BSingleton-Pattern/)\n\n","tags":["demo","设计模式","单例模式"],"categories":["设计模式"]},{"title":"设计模式(0)-入门","url":"/2020/12/30/设计模式/设计模式(0)-入门/","content":"## 摘要\n\n* 简述了设计模式是什么以及优点\n* 按照目的和作用范围进行了划分\n* 介绍了23种设计模式\n\n\n<!--more-->\n\n## 简介\n\n目前软件工程的设计模式主要是23种，可以根据模式的目的和模式的作用范围进行分类。设计模式的本质是面向对象设计原则的实际运用，是对类的封装性，继承性和多态性以及类之间的关联关系和组合关系的充分理解。\n\n优点\n\n* 思维能力，编程能力，设计能力\n* 设计标准化，代码编制工程化\n* 保证代码可重复用性，可读性，可靠性，灵活性，可维护性\n\n## 分类\n\n* 目的划分\n  * 创建型模式\n    * 将对象的创建与使用分离\n    * 五种创建模式\n      * 单例\n      * 原型\n      * 工厂方法\n      * 抽象工厂\n      * 建造者\n  * 结构型模式\n    * 描述如何将类或对象以某种布局组成更大的结构\n    * 七种结构型模式\n      * 代理\n      * 适配器\n      * 桥接\n      * 装饰\n      * 外观\n      * 享元\n      * 组合\n  * 行为型模式\n    * 描述类或者对象之间相互协作共同完成单个对象无法完成的任务，以及职责划分\n    * 十一种行为型模式\n      * 模板方法\n      * 策略\n      * 命令\n      * 职责链\n      * 状态\n      * 观察者\n      * 中介者\n      * 迭代器\n      * 访问者\n      * 备忘录\n      * 解释器\n* 作用范围划分\n  * 类模式\n    * 处理类和子类的关系，这些关系通过继承来建立，是静态的，编译时刻就稳定下来了\n    * 四种类模式\n      * (类)适配器\n      * 模板方法\n      * 解释器\n      * 工厂方法\n  * 对象模式\n    * 用于处理对象之间的关系，这些关系可以通过组合或者聚合来实现，在运行时刻是可以变化的具有动态性\n    * 十九种对象模式\n\n## 具体介绍\n\n1. 单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。\n2. 原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。\n3. 工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。\n4. 抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。\n5. 建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。\n6. 代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。\n7. 适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。\n8. 桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。\n9. 装饰（Decorator）模式：动态的给对象增加一些职责，即增加其额外的功能。\n10. 外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。\n11. 享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。\n12. 组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。\n13. 模板方法（TemplateMethod）模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。\n14. 策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。\n15. 命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。\n16. 职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。\n17. 状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。\n18. 观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。\n19. 中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。\n20. 迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。\n21. 访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。\n22. 备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。\n23. 解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。\n\n## 参考\n\n[1].[GoF 的 23 种设计模式的分类和功能](http://c.biancheng.net/view/1320.html)\n\n[2].[软件设计模式概述](http://c.biancheng.net/view/1317.html)\n\n\n\n","tags":["设计模式","入门"],"categories":["设计模式"]},{"title":"SpringBoot系列(3)——AOP实战1-权限&日志","url":"/2020/12/29/SpringBoot/SpringBoot系列(3)——AOP实战1-权限&日志/","content":"## 摘要\n\n* 实现简单的权限控制\n* 实现简单的日志\n\n\n<!--more-->\n\n## 权限控制\n\n### pom\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-aop</artifactId>\n</dependency>\n```\n\n### annotation\n\n```java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface PermissionAnnotation{}\n```\n\n### aspect\n\n```java\n@Aspect\n@Component\n@Order(1)\npublic class PermissionFirstAdvice {\n\n    @Pointcut(\"@annotation(xx.xx.xx.PermissionAnnotation)\")\n    private void permissionCheck() {\n    }\n\n    @Around(\"permissionCheck()\")\n    public Object permissionCheckFirst(ProceedingJoinPoint joinPoint) throws Throwable {\n        System.out.println(System.currentTimeMillis());\n\n        //获取请求参数\n        Object[] objects = joinPoint.getArgs();\n        String userName = (String) objects[0];\n\n        if (!userName.equals(\"admin\")) {\n            return \"失败\";\n        }\n        return joinPoint.proceed();\n    }\n}\n```\n\n### controller\n\n```java\n@RestController\n@RequestMapping(value = \"/permission\")\npublic class TestController {\n    \n    @RequestMapping(value = \"/check\", method = RequestMethod.POST)\n    @PermissionsAnnotation()\n    public String getGroupList(@RequestParam String userName) {\n        return \"Hello \"+userName;\n    }\n}\n```\n\n## 日志\n\n### pom\n\n```xml\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.3.5.RELEASE</version>\n        <relativePath/>\n    </parent>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-aop</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>cn.hutool</groupId>\n            <artifactId>hutool-all</artifactId>\n            <version>5.5.6</version>\n        </dependency>\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>com.alibaba</groupId>\n            <artifactId>fastjson</artifactId>\n            <version>1.2.70</version>\n        </dependency>\n    </dependencies>\n```\n\n### aspect\n\n```java\n@Aspect\n@Component\npublic class OperLogAspect {\n\n    //操作切入点\n    @Pointcut(\"@annotation(com.bothsavage.annotation.OperLog)\")\n    public void operLogPoinCut() {}\n\n\n    //正常返回通知\n    @AfterReturning(value = \"operLogPoinCut()\", returning = \"keys\")\n    public void saveOperLog(JoinPoint joinPoint, Object keys) {\n        RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();\n        HttpServletRequest request = (HttpServletRequest) requestAttributes.resolveReference(RequestAttributes.REFERENCE_REQUEST);\n        OperationLog operlog = new OperationLog();\n        try {\n            MethodSignature signature = (MethodSignature) joinPoint.getSignature();\n            Method method = signature.getMethod();\n            String className = joinPoint.getTarget().getClass().getName();\n            String methodName = method.getName();\n            OperLog opLog = method.getAnnotation(OperLog.class);\n            methodName = className + \".\" + methodName;\n            Map<String, String> rtnMap = converMap(request.getParameterMap());\n            String params = JSON.toJSONString(rtnMap);\n\n            operlog.setOperId(IdUtil.randomUUID());\n            operlog.setOperModul(opLog.operModul());\n            operlog.setOperType(opLog.operType());\n            operlog.setOperDesc(opLog.operDesc());\n            operlog.setOperMethod(methodName); // 请求方法\n            operlog.setOperRequParam(params); // 请求参数\n            operlog.setOperRespParam(JSON.toJSONString(keys)); // 返回结果\n            operlog.setOperUri(request.getRequestURI()); // 请求URI\n            operlog.setOperCreateTime(new Date()); // 创建时间\n\n            //打印日志\n            System.out.println(JSON.toJSONString(operlog));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n        //转换request 请求参数\n    public Map<String, String> converMap(Map<String, String[]> paramMap) {\n        Map<String, String> rtnMap = new HashMap<String, String>();\n        for (String key : paramMap.keySet()) {\n            rtnMap.put(key, paramMap.get(key)[0]);\n        }\n        return rtnMap;\n    }\n\n    //转换异常信息为字符串\n    public String stackTraceToString(String exceptionName, String exceptionMessage, StackTraceElement[] elements) {\n        StringBuffer strbuff = new StringBuffer();\n        for (StackTraceElement stet : elements) {\n            strbuff.append(stet + \"\\n\");\n        }\n        String message = exceptionName + \":\" + exceptionMessage + \"\\n\\t\" + strbuff.toString();\n        return message;\n    }\n}\n```\n\n### 实体类\n\n```java\npackage com.bothsavage.entity;\n\nimport lombok.Data;\n\nimport java.util.Date;\n\n@Data\npublic class OperationLog {\n    private String operId;\n    private String operModul;\n    private String operType;\n    private String operDesc;\n    private String OperMethod;\n    private String OperRequParam;\n    private String OperRespParam;\n    private String OperUserId;\n    private String OperUserName;\n    private String OperIp;\n    private String OperUri;\n    private Date OperCreateTime;\n    private String OperVer;\n}\n```\n\n### annotation\n\n```java\n@Target(ElementType.METHOD) //注解放置的目标位置,METHOD是可注解在方法级别上\n@Retention(RetentionPolicy.RUNTIME) //注解在哪个阶段执行\n@Documented\npublic @interface OperLog {\n    String operModul() default \"\"; // 操作模块\n    String operType() default \"\";  // 操作类型\n    String operDesc() default \"\";  // 操作说明\n}\n```\n\n### controller\n\n```java\n@RestController\npublic class TestController {\n\n    @GetMapping(\"/test/{testName}\")\n    @OperLog(operModul = \"测试模块\",operType = \"test\",operDesc = \"这个是用来测试的\")\n    public String test(@PathVariable String testName){\n        return  \"hello\"+testName;\n    }\n}\n```\n\n\n\n## 参考\n\n[1].[把自己牛逼到了，在SpringBoot用AOP切面实现一个权限校验...](https://mp.weixin.qq.com/s/2e8x9n4p49kZzM2Fr2cTVw)\n\n[2].[Spring AOP 实现功能权限校验功能](https://blog.csdn.net/houxuehan/article/details/51745175?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-3&spm=1001.2101.3001.4242)\n\n[3].[SpringAop实现权限校验与日志打印](https://blog.csdn.net/sinat_34620530/article/details/103993158?utm_medium=distribute.pc_relevant_t0.none-task-blog-searchFromBaidu-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-searchFromBaidu-1.control)\n\n[4].[基于Spring AOP实现的权限控制](https://www.cnblogs.com/sxkgeek/p/9985929.html)\n\n[5].[使用SpringBoot AOP 记录操作日志、异常日志](https://www.cnblogs.com/wm-dv/p/11735828.html)\n\n","tags":["Spring Boot","aop","demo"],"categories":["Spring Boot"]},{"title":"SpringBoot系列(2)——AOP-静态代理与动态代理","url":"/2020/12/29/SpringBoot/SpringBoot系列(2)——AOP-静态代理与动态代理/","content":"## 摘要\n\n* 分别演示静态代理和动态代理\n\n<!--more-->\n\n## 静态代理\n\n### 手动代理\n\n#### interface\n\n```java\npublic interface Interface_ {\n    public void do();\n}\n```\n\n#### 需要被加强的类\n\n```java\npublic class Object_ implements Interface_{\n    @Override\n    public void do() {\n        System.out.println(\"do\");\n    }\n}\n```\n\n#### 代理类\n\n```java\npublic class Object_Agent implements Interface_{\n\n    private Object_ object_;\n    public Object_Agent(Object_ object_) {\n        this.object_ = object_;\n    }\n\n    @Override\n    public  void do() {\n        System.out.println(\"enhance\");\n        object_.do();\n    }\n    \n    public static void main(String[] args) {\n        Object_ object_ = new Object_();\n        Object_Agent agent = new Object_Agent(object_);\n        agent.do();\n    }\n\n}\n```\n\n\n\n### AspectJ静态\n\n* 编写方式和spring aop没有区别\n\n- Aspectj并不是动态的在运行时生成代理类，而是在编译的时候就植入代码到class文件\n- 由于是静态织入的，所以性能相对来说比较好\n\n\n\n## 动态代理\n\n> * JDK动态代理是基于接口的方式，代理类和目标类都实现同一个接口。\n> * CGLib动态代理是代理类去继承目标类，然后重写其中目标类的方法。\n\n### JDK动态代理\n\n#### 接口\n\n```java\npublic interface Interface_ {\n    public void do();\n}\n```\n\n#### 需要被加强的类\n\n```java\npublic class Object_ implements Interface_{\n    @Override\n    public void do() {\n        System.out.println(\"do\");\n    }\n}\n```\n\n#### 处理器实现类\n\n```java\npublic class InvocationHandlerImpl implements InvocationHandler{\n\n    private Object object;\n    public InvocationHandlerImpl(Object object)\n    {\n        this.object = object;\n    }\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable\n    {\n        System.out.println(\"enhance\");\n        Object object = method.invoke(object, args);\n        return object;\n    }\n}\n```\n\n#### 测试\n\n```java\npublic class DynamicProxyDemonstration\n{\n    public static void main(String[] args)\n    {\n        Interface_ object_ = new Object_();\n        InvocationHandler handler = new InvocationHandlerImpl(object_);\n        ClassLoader loader = object_.getClass().getClassLoader();\n        Class[] interfaces = object_.getClass().getInterfaces();\n        Interface_ object__ = (Interface_) Proxy.newProxyInstance(loader, interfaces, handler); \n        object__.do();\n    }\n \n}\n```\n\n\n\n### CGlib动态代理\n\n#### POM\n\n```xml\n<dependency>\n        <groupId>cglib</groupId>\n        <artifactId>cglib</artifactId>\n        <version>2.2.2</version>\n</dependency>\n```\n\n#### 需要被加强的类\n\n```java\npublic class Object_{\n    public  void do() {\n        System.out.println(\"do\");\n    }\n}\n```\n\n#### 方法拦截器\n\n```java\npublic class MyMethodInterceptor implements MethodInterceptor{\n    @Override\n    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n        System.out.println(\"enhance\");\n        Object object = proxy.invokeSuper(obj, args);\n        return object;\n    }  \n}\n```\n\n#### 测试\n\n```java\npublic class CgLibProxy {\n    public static void main(String[] args) {\n        //创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数\n        Enhancer enhancer = new Enhancer();\n        //设置目标类的字节码文件\n        enhancer.setSuperclass(Object_.class);\n        //设置回调函数\n        enhancer.setCallback(new MyMethodInterceptor());\n        //创建加运行\n        Object_ proxyObject_ = (Object_)enhancer.create();\n        proxyObject_.do();       \n    }\n}\n```\n\n## 为啥转变被CGlib\n\n一般写代码：\n\n```java\n@Autowired\nUserService userService;\n```\n\n出错代码：\n\n```\n@Autowired\nUserServiceImpl userService;\n```\n\n![启动报错](https://img2018.cnblogs.com/blog/1822265/201910/1822265-20191029133357222-1265293381.png)\n\n JDK 动态代理是基于接口的，代理生成的对象只能赋值给接口变量。\n\n而 CGLIB 就不存在这个问题。因为 CGLIB 是通过生成子类来实现的，代理对象无论是赋值给接口还是实现类这两者都是代理对象的父类。\n\n## 总结\n\n* Spring5 默认aop实现为CGlib\n* JDK动态代理是基于接口的，CGlib动态代理是基于继承的\n\n## 参考\n\n[1].[CGLib动态代理](https://www.cnblogs.com/wyq1995/p/10945034.html)\n\n[2].[java反射和代理](https://www.cnblogs.com/wyq1995/p/10936286.html)\n\n[3].[惊人！Spring5 AOP 默认使用Cglib? 从现象到源码深度分析](https://www.cnblogs.com/coderxiaohei/p/11758239.html)","tags":["Spring Boot","aop","demo"],"categories":["Spring Boot"]},{"title":"SpringBoot系列(1)——AOP-入门","url":"/2020/12/28/SpringBoot/SpringBoot系列(1)——AOP-入门/","content":"\n## 摘要\n\n* aop关键词\n* spring aop小demo\n\n<!--more-->\n\n## 概念\n\n> 使用场景：与业务无关的且经常使用到的公共功能如鉴权，日志，性能优化，事务，错误处理，资源池，同步，审计，幂等等\n\n>  优点：降低耦合度，易扩展，高复用\n>\n>  实现方式：静态代理(AspectJ) + 动态代理（CGlib/Jdk）\n\n### aop关键词\n\n- 连接点(Joinpoint):连接点就是增强的实现\n- 切点(PointCut):就是那些需要应用切面的方法 \n- 增强(Advice)\n  - 前置通知(before)\n  - 后置通知(after)\n  - 异常通知(afterThrowing)\n  - 返回通知(afterReturning)\n  - 环绕通知(around)\n- 目标对象(Target)\n- 织入(Weaving):添加到对目标类具体连接点上的过程。\n- 代理类(Proxy):一个类被AOP织入增强后，就产生了一个代理类。\n- 切面(Aspect):切面由切点和增强组成，它既包括了横切逻辑的定义，也包括了连接点的定义\n  ![](https://gitee.com/BothSavage/PicGo/raw/master/image/20210102170844.png)\n### 五种返回类型\n\n* @Before： 标识一个前置增强方法，相当于BeforeAdvice的功能. \n* @After： final增强，不管是抛出异常或者正常退出都会执行. \n* @AfterReturning： 后置增强，似于AfterReturningAdvice, 方法正常退出时执行.\n*  @AfterThrowing： 异常抛出增强，相当于ThrowsAdvice. @Around： 环绕增强，相当于MethodInterceptor. \n\n### 连接点限制\n\n- 任意公共方法的执行：execution(public * *(..))\n- 任何一个以“set”开始的方法的执行：execution(* set*(..))\n- AccountService 接口的任意方法的执行：execution(* com.xyz.service.AccountService.*(..))\n- 定义在service包里的任意方法的执行： execution(* com.xyz.service.*.*(..))\n- 定义在service包和所有子包里的任意类的任意方法的执行：execution(* com.xyz.service..*.*(..))\n\n- 定义在pointcutexp包和所有子包里的JoinPointObjP2类的任意方法的执行：execution(*com.test.spring.aop.pointcutexp..JoinPointObjP2.*(..))\")\n- pointcutexp包里的任意类： within(com.test.spring.aop.pointcutexp.*)\n- pointcutexp包和所有子包里的任意类：within(com.test.spring.aop.pointcutexp..*)\n- 实现了Intf接口的所有类,如果Intf不是接口,限定Intf单个类：this(com.test.spring.aop.pointcutexp.Intf)\n- 当一个实现了接口的类被AOP的时候,用getBean方法必须cast为接口类型,不能为该类的类型\n- 带有@Transactional标注的所有类的任意方法： @within(org.springframework.transaction.annotation.Transactional) @target(org.springframework.transaction.annotation.Transactional)\n- 带有@Transactional标注的任意方法：\n  @annotation(org.springframework.transaction.annotation.Transactional)\n  @within和@target针对类的注解,@annotation是针对方法的注解\n- 参数带有@Transactional标注的方法：@args(org.springframework.transaction.annotation.Transactional)\n- 参数为String类型(运行是决定)的方法： args(String)\n\n## Spring aop测试\n\n### pom\n\n```xml\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>2.3.5.RELEASE</version>\n    <relativePath/>\n</parent>\n\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-aop</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-test</artifactId>\n        <scope>test</scope>\n    </dependency>\n</dependencies>\n```\n\n### aspect\n\n```java\n@Component\n@Aspect \npublic class DemoAspect {\n\n\n    //切入点1：匹配xxx类下的方法名以demo开头、参数类型为int的public方法\n    @Pointcut(\"execution(public * com.bothsavage.service.DemoService.demo*(int))\")\n    public void matchCondition() {}\n\n    //切入点2：匹配xxx类下的方法名以demo开头、参数类型为long的public方法\n    @Pointcut(\"execution(public * com.bothsavage.service.DemoService.demo1*(long))\")\n    public void matchCondition_() {}\n\n    //前置\n    @Before(\"matchCondition()\")\n    public void before() {\n        System.out.println(\"Before\");\n    }\n\n    //全局后置\n    @After(\"matchCondition()\")\n    public void after(){\n        System.out.println(\"after\");\n    }\n\n    //返回后置\n    @AfterReturning(\"matchCondition()\")\n    public void afterReturning(){\n        System.out.println(\"afterReturning\");\n    }\n\n    //抛出后置\n    @AfterThrowing(\"matchCondition()\")\n    public void afterThrowing(){\n        System.out.println(\"afterThrowing\");\n    }\n\n    @Around(\"matchCondition_()\")\n    public Object around(ProceedingJoinPoint joinPoint) {\n        Object result = null;\n        System.out.println(\"before\");\n        try{\n            result = joinPoint.proceed(joinPoint.getArgs());//获取参数\n            System.out.println(\"after\");\n        } catch (Throwable e) {\n            System.out.println(\"after exception\");\n            e.printStackTrace();\n        } finally {\n            System.out.println(\"finally\");\n        }\n        return result;\n    }\n\n}\n```\n\n### service\n\n```java\n@Service\npublic class DemoService {\n\n    public void demo(int arg1){\n        System.out.println(arg1);\n    }\n\n    public void demo1(long arg1){\n        System.out.println(arg1);\n    }\n    \n}\n```\n\n\n\n### test\n\n```java\n@SpringBootTest\npublic class DemoServiceTest {\n    \n    @Autowired\n    DemoService demoService;\n\n    //测试单独四个\n    @Test\n    public void testDemo1(){\n        demoService.demo(1);\n    }\n    \n    //测试around\n    @Test\n    public void testDemo2(){\n        demoService.demo1(1L);\n    }\n}\n```\n\n## 参考\n\n[1].[Spring AOP——简单粗暴，小白教学](https://blog.csdn.net/qq_41981107/article/details/87920537)\n\n[2].[CGLib动态代理](https://www.cnblogs.com/wyq1995/p/10945034.html)\n\n[3].[关于 Spring AOP (AspectJ) 你该知晓的一切](https://zhuanlan.zhihu.com/p/25522841)\n\n[4].[Spring AOP用法详解](https://www.cnblogs.com/liantdev/p/10125284.html)\n","tags":["Spring Boot","aop","demo"],"categories":["Spring Boot"]},{"title":"Gitee图床+typora&notion+snipaste","url":"/2020/12/26/杂项/Gitee图床+typora&notion+snipaste/","content":"## 摘要\n* 软件的下载地址\n* 配置PicGo图床，把gitee作为图床\n* markdown软件typora，notion1简介\n* 截图软件snipaste快速配合PicGo\n\n <!--more--> \n\n> tips: 以下{$xxx}均为用户自定义\n\n## 软件下载\n\n> [1].[图床软件PicGo](https://molunerfinn.com/PicGo/)\n>\n> [2].[typota](https://typora.io/)\n>\n> [3].[notion](https://www.notion.so/)\n>\n> [4].[snipaste](https://www.snipaste.com/)\n\n## 使用\n\n### typora,notion\n\ntypora和notion都是支持Markdown语法的文档编辑器，但是notion支持更多的功能，比如生成如下形式的文档\n\n![](https://gitee.com/BothSavage/PicGo/raw/master/image/20201226130027.png)\n\n### picgo\n\n所谓图床工具，就是自动把本地图片转换成链接的一款工具，网络上有很多图床工具，就目前使用种类而言，PicGo 算得上一款比较优秀的图床工具。它是一款用 `Electron-vue` 开发的软件，可以支持微博，七牛云，腾讯云COS，又拍云，GitHub，阿里云OSS，SM.MS，imgur 等8种常用图床，功能强大，简单易用\n\n> 推荐使用gitee，因为github访问不稳定\n\n- 直接搜索gitee在PicG的插件界面，安装picgo-plugin-gitee-uploader\n- 对应填好如下属性\n\n- - 其中repo为**用户名/仓库名**\n  - branch默认为master\n  - token的获取方法在下面\n  - path为子文件为目录\n\n- ![](https://gitee.com/BothSavage/PicGo/raw/master/image/1602233669972-05e582dc-5379-4b2b-ac8d-4ecb1789093c.png)\n\n### snipaste\n\n这是一款强大的截图工具，默认热键为F1，截图完成后点击右下角复制到剪切板，再使用图床的默认热键，快速完成图片上传\n\n![](https://gitee.com/BothSavage/PicGo/raw/master/image/20201226131235.png)\n\n## 参考\n\n[1].[Typora 完全使用详解](https://sspai.com/post/54912/)\n\n[2].[PicGo图床使用](https://www.yuque.com/u2063760/xbfae1/mipufs)\n\n\n\n\n\n","tags":["工具","图床","git"],"categories":["杂项"]},{"title":"Hexo结合Stun静态博客搭建从入门到入土","url":"/2020/12/19/杂项/Hexo结合Stun静态博客搭建从入门到入土 - 副本/","content":"## 摘要\n* 安装npm，安装hexo相关依赖，安装主题stun\n* 修改hexo配置，修改stun配置，部署到github，gitee实现静态访问\n* 给博客加上全局搜索，访问量统计\n* hexo博客编写模板\n\n <!--more--> \n\n> tips: 以下{$xxx}均为用户自定义\n\n## 搭建环境\n\n### 创建仓库\n\n1.github\n\n> 仓库命名为：{$你的ID}.github.io\n\n2.gitee\n\n> 仓库命名为：{$你的ID}  \n\n***仓库名大小写一致，访问路径也是***\n\n### 环境安装\n\n1.安装npm\n\n> https://nodejs.org/en/download/\n\n2.安装cnpm\n\n```\nnpm install cnpm\n```\n\n3.安装博客搭建框架hexo\n\n```\ncnpm install -g hexo-cli\n```\n\n4.新建一个文件夹，并且之后所有操作都基于该文件夹\n\n```\nmkdir {$xxx}\ncd {$xxx}\n```\n\n5.安装依赖，下载主题\n\n```\ncnpm install --save hexo-deployer-git \ncnpm install --save hexo-render-pug\ncnpm install --save hexo-generator-search \ngit clone https://github.com/liuyib/hexo-theme-stun.git themes/stun\n```\n\n6.增加页面导航\n\n```\nhexo new page categories\nhexo new page tags\n```\n\n> 项目目录/source/categories/index.md  加上\n>\n> ```\n> type: categories\n> ```\n>\n> 项目目录/source/tags/index.md  加上\n>\n> ```\n> type: tags\n> ```\n\n### 修改配置文件\n\n1.修改部署文件夹下/_config.yml（挑选重要部分修改）\n\n```\n#展示设置\ntitle: {$自定义文字}\nlanguage: zh-CN \nurl: {$博客地址}\n\n#主题\ntheme: stun\n\n#git相关\ndeploy:\n  type: git\n  repo: \n  \tgithub: {$你的博客仓库}\n  \tgitee: {$你的博客仓库}\n  branch: master\n\n#搜索相关\nsearch:\n  path: search.json\n  field: post\n  content: true\n```\n\n2.修改部署文件夹下/themes/stun/_config.yml(挑选重要部分修改)\n\n```\n#取消导航栏注释（注意空格对齐）\nmenu:\n  categories: /categories/ || fas fa-layer-group\n  tags: /tags/ || fas fa-tags\n  \n#更改图标(最好使用链接地址，我这里使用的图床，图床使用见下一篇博客)\nfavicon:\n  small: https://gitee.com/BothSavage/PicGo/raw/master/image/favicon-16x16.png\n  medium: https://gitee.com/BothSavage/PicGo/raw/master/image/favicon-32x32.png\n\n#更改背景大图\nheader:\n  bg_image:\n    enable: true\n    url: https://gitee.com/BothSavage/PicGo/raw/master/image/背景.png\n\n#更改头像大图，并设为圆形\nauthor:\n  avatar:\n    url: https://gitee.com/BothSavage/PicGo/raw/master/image/头像.png\n    rounded: true\n    \n#打开访问统计\nbusuanzi:\n  enable: true\n  \n#打开搜索功能\nlocal_search:\n  enable: true\n\n```\n\n### 运行\n\n1.基础命令\n\n```\nhexo c  #清理一下\nhexo g  #生成\nhexo s  #部署到本地4000端口\nhexo d  #部署到远程Github仓库\n```\n\n2.推荐命令\n\n```\n#第一次尝试本地是否能访问\nhexo c  && hexo g && hexo s\n#以后每次添加文章\nhexo c  && hexo g && hexo d\n```\n\n### 博客文件存放地点\n\n> 项目目录/source/_posts\n\n## markdown文件规范\n\n1.文章元数据\n\n```\n#分别指定文章标题，时间，类别，标签\n---\ntitle: Hexo结合Stun静态博客搭建从入门到入土\ndate: 2020-12-19  20:40:11\ncategories:\n- 杂项\ntags:\n- 前端\n- 建站\n---\n```\n\n2.主页不显示文章全部\n\n```\n 上面是显示内容\n <!--more--> \n```\n\n## 其他高级功能\n\nstun主题支持\n\n* 评论系统\n* 站长工具\n* 数据公式\n* 网站特效\n* ................\n\n详情请查看\n\nhttps://theme-stun.github.io/docs/zh-CN/\n\n## 参考\n\n[1].[菜鸟教程：NodeJS安装配置](https://www.runoob.com/nodejs/nodejs-install-setup.html)\n\n[2].[Stun主题指南](https://theme-stun.github.io/docs/zh-CN/)\n\n[3].[静态博客搭建](https://www.yuque.com/u2063760/xbfae1/gf45k1)\n\n[4].[_more截断文章_多标签添加](https://blog.csdn.net/Aoman_Hao/article/details/79291741)\n\n[5].[在gitee上部署静态网站（或者个人博客）](https://blog.csdn.net/zhangyu4863/article/details/80473412)\n\n","tags":["前端","建站"],"categories":["杂项"]},{"title":"Hello World","url":"/1920/06/25/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!--more-->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]